//====================================//
// インクルード
//====================================//
#include "setup.h"
//====================================//
// グローバル変数の宣言
//====================================//
uint8_t 	start;		// 0:セットアップ中	1:セットアップ完了

// タイマ関連
uint16_t 		cntSetup1 = 0;		// セットアップで使用
uint16_t 		cntSetup2 = 0;		// セットアップで使用
uint16_t 		cntSetup3 = 0;		// セットアップで使用
int16_t			cntSwitchUD;	// スイッチ長押し判定用右
int16_t			cntSwitchLR;	// スイッチ長押し判定用左

// スイッチ関連
int8_t pushLR = 0;
int8_t pushUD = 0;

// パターン関連
uint8_t push = 0;
uint8_t push1 = 0;
uint8_t pattern_sensor = 1;
uint8_t pattern_parameter = 1;
uint8_t pattern_parameter2 = 1;
uint8_t pattern_parameter3 = 1;
uint8_t pattern_parameter4 = 1;
uint8_t pattern_gain = 1;
uint8_t pattern_gain2 = 1;
uint8_t pattern_gain3 = 1;
uint8_t pattern_speedseting = 1;
uint8_t pattern_msd = 1;
uint8_t pattern_flash = 1;
uint8_t pattern_scanf = 0;

// フラグ関連
uint8_t setting_1meter;
uint8_t setting_2meter;
uint8_t setting_3meter;
uint8_t motor_test = 0;
uint8_t servo_test = 0;
uint8_t servo_test2 = 0;
uint8_t fixSpeed = 0;
uint8_t str[8];

// パラメータ関連
uint8_t motorTestPwm = 10;

//====================================//
// プロトタイプ宣言
//====================================//
void data_select ( uint8_t *data , uint8_t button );
void data_tuningUD ( void *data, uint8_t add );
void data_tuningLR ( void *data, uint8_t add );

int16_t cnttest = 0;
///////////////////////////////////////////////////////////////
// モジュール名 setup
// 処理概要     走行前設定
// 引数         なし
// 戻り値       なし
///////////////////////////////////////////////////////////////
void setup( void )
{
	uint8_t cnt_led, sd_sw;
	int16_t i, j, k;
	
	// ディップスイッチで項目選択
	switch ( getSWrotary() ) {
		//------------------------------------------------------------------
		// スタート待ち
		//------------------------------------------------------------------
		case 0x0:
			// lcdRowPrintf(UPROW, "START   ");
			// lcdRowPrintf(LOWROW, "STOP %2dm", stopping_meter );
			
			// // ゲート検出
			// if ( startbar_get() ) ledOut(LED_B);
			// else 	ledOut(LED_R);
			// // 停止距離入力
			// data_tuningUD ( &stopping_meter, 1 );
			
			// modeAngle = 0;
			// data_select( &servo_test, SW_RIGHT );
			// if ( servo_test == 1 ) servoPwmOut( ServoPwm );
			// else servoPwmOut( 0 );
			
			// // プッシュスイッチ押下待ち
			// if ( taswGet() == SW_PUSH ) {
			// 	start = START_COUNT;
			// } else if ( taswGet() == SW_LEFT ) {
			// 	start = START_GATE;
			// } else if ( taswGet() == SW_RIGHT ) {
			// 	modePushcart = 1;
			// 	start = START_COUNT;
			// }
			
			break;
		//------------------------------------------------------------------
		// パラメータ調整(通常トレース)
		//------------------------------------------------------------------
		case 0x1:
			
			break;
			
		//------------------------------------------------------------------
		// パラメータ調整(クランク)
		//------------------------------------------------------------------
		case 0x2:
			
			break;
		//------------------------------------------------------------------
		// パラメータ調整(レーンチェンジ)
		//------------------------------------------------------------------
		case 0x3:
			
			break;
		
		//------------------------------------------------------------------
		// パラメータ調整(坂道、角度)
		//------------------------------------------------------------------
		case 0x4:
			
			break;
		//------------------------------------------------------------------
		// ゲイン調整(サーボ)
		//------------------------------------------------------------------
		case 0x5:
			// lcdRowPrintf(UPROW, "kp ki kd");
			
			// data_select( &servo_test, SW_PUSH );
			// if ( servo_test == 1 ) servoPwmOut( ServoPwm );
			// else servoPwmOut( 0 );
			
			// data_tuningLR( &pattern_gain, 1 );
			// if ( pattern_gain == 4 ) pattern_gain = 1;
			// else if ( pattern_gain == 0 ) pattern_gain = 3;
			
			// switch( pattern_gain ) {
			// 	case 1:
			// 		// kp
			// 		//値を点滅
			// 		if ( cntSetup1 >= 500 ) cntSetup1 = 0;
			// 		if ( cntSetup1 < 250 ) {
			// 			lcdRowPrintf(LOWROW, "   %2d %2d", ki_buff, kd_buff);
			// 		} else {
			// 			lcdRowPrintf(LOWROW, "%2d %2d %2d", kp_buff, ki_buff, kd_buff);
			// 		}
					
			// 		data_tuningUD ( &kp_buff, 1 );
			// 		break;
			// 	case 2:
			// 		// ki
			// 		//値を点滅
			// 		if ( cntSetup1 >= 500 ) cntSetup1 = 0;
			// 		if ( cntSetup1 < 250 ) {
			// 			lcdRowPrintf(LOWROW, "%2d    %2d", kp_buff, kd_buff);
			// 		} else {
			// 			lcdRowPrintf(LOWROW, "%2d %2d %2d", kp_buff, ki_buff, kd_buff);
			// 		}
					
			// 		data_tuningUD ( &ki_buff, 1 );
			// 		break;
			// 	case 3:
			// 		// kd
			// 		//値を点滅
			// 		if ( cntSetup1 >= 500 ) cntSetup1 = 0;
			// 		if ( cntSetup1 < 250 ) {
			// 			lcdRowPrintf(LOWROW, "%2d %2d   ", kp_buff, ki_buff);
			// 		} else {
			// 			lcdRowPrintf(LOWROW, "%2d %2d %2d", kp_buff, ki_buff, kd_buff);
			// 		}
					
			// 		data_tuningUD ( &kd_buff, 1 );
			// 		break;
			// }
			break;
		//------------------------------------------------------------------
		// ゲイン調整(角度)
		//------------------------------------------------------------------
		case 0x6:
			
			break;
		//------------------------------------------------------------------
		// ゲイン調整(速度)
		//------------------------------------------------------------------
		case 0x7:
			
			break;
		//------------------------------------------------------------------
		// プリセットパラメータ
		//------------------------------------------------------------------
		case 0x8:
			
			break;
		//------------------------------------------------------------------
		// Motor_test
		//------------------------------------------------------------------
		case 0x9:
			// data_tuningLR( &pattern_sensor, 1 );
			// modeAngle = 0;
			
			// if ( pattern_sensor == 14 ) pattern_sensor = 1;
			// else if ( pattern_sensor == 0 ) pattern_sensor = 13;
			
			// switch( pattern_sensor ) {
			// 	case 1:
			// 		// LED
			// 		lcdRowPrintf(UPROW, "LED     ");
			// 		lcdRowPrintf(LOWROW, "        ");
			// 		cnt_led = 0x00;
			// 		if ( taswGet() == SW_PUSH) {
			// 			while(1){
			// 			while( cnt_led <= 0x7 ) {
			// 				ledOut( cnt_led );
			// 				cnt_led++;
			// 				waitLcd(200);
 			// 			}
			// 			cnt_led = 0x00;
			// 			}
			// 		}
			// 		break;
					
			// 	case 2:
			// 		// ジャイロ
			// 		if ( taswGet() == SW_TOP ) PichAngleIMU = 0;
			// 		if ( taswGet() == SW_DOWN ) RollAngleIMU = 0;
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(UPROW, "Roll%4d", (short)RollAngleIMU);
			// 			lcdRowPrintf(LOWROW, "Pich%4d",(short)PichAngleIMU);
			// 		}
			// 		break;
					
			// 	case 3:
			// 		// エンコーダ
			// 		lcdRowPrintf(UPROW, "Encoder ");
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			// lcdRowPrintf(LOWROW, "   %4.1f",(double)EncoderTotal/PALSE_MILLIMETER);
			// 			// lcdRowPrintf(LOWROW, "   %5d",EncoderTotal);
			// 			lcdRowPrintf(LOWROW, "   %5d",Encoder);
			// 		}
			// 		break;
							
			// 	case 4:
			// 		// ポテンションメーター
			// 		lcdRowPrintf(UPROW, "Angle   ");
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(LOWROW, "   %5d",getServoAngle());
			// 		}
			// 		break;
					
			// 	case 5:
			// 		// アナログセンサ
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(UPROW, "R   %4d",sensorR);
			// 			lcdRowPrintf(LOWROW, "L   %4d",sensorL);
			// 		}
			// 		break;
					
			// 	case 6:
			// 		// デジタル風アナログセンサ, ゲートセンサ
			// 		motor_test = 0;
			// 		data_tuningUD ( &sensorG_th, 1 );
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			startbar_get();
			// 			lcdRowPrintf(UPROW, "G%3d%4d", sensorG_th, sensorG);
			// 			lcdRowPrintf(LOWROW, "D    0x%x", sensor_inp());
			// 		}
			// 		break;
					
			// 	case 7:
			// 		// モーターテスト
			// 		lcdRowPrintf(UPROW, "Motortes");
			// 		lcdRowPrintf(LOWROW, "    %3d%%",motorTestPwm);
			// 		demo = 0;
			// 		data_tuningUD ( &motorTestPwm, 1 );
			// 		if ( motor_test == 1 ) {
			// 			// if ( cntSetup1 >= 500 ) {
			// 				// cntSetup1 = 0;
			// 				diff( motorTestPwm );
			// 			// }
			// 			// motorPwmOut(motorTestPwm, motorTestPwm, motorTestPwm, motorTestPwm);
			// 		} else {
			// 			motorPwmOut(0, 0, 0, 0);
			// 		}
					
			// 		data_select( &motor_test, SW_PUSH );
			// 		break;
			// 	case 8:
			// 		// サーボテスト
			// 		lcdRowPrintf(UPROW, "Servo   ");
			// 		lcdRowPrintf(LOWROW, "        ");
			// 		if ( motor_test == 1 ) servoPwmOut( 20 );
			// 		else				servoPwmOut( 0 );
					
			// 		data_select( &motor_test, SW_PUSH );
			// 		break;
			// 	case 9:
			// 		// ラインセンサ差分
			// 		lcdRowPrintf(UPROW, "gASensor");
					
			// 		motor_test = 0;
			// 		if ( cntSetup1 >= 100 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(LOWROW, "   %5d", getAnalogSensor());
			// 		}
			// 		break;
					
			// 	case 10:
			// 		// 旋回角度
			// 		lcdRowPrintf(UPROW, "IMU %4d", (short)TurningAngleIMU);
			// 		lcdRowPrintf(LOWROW, "        ");
			// 		if ( taswGet() == SW_PUSH ) TurningAngleIMU = 0;
			// 		if ( taswGet() == SW_TOP ) caribrateIMU();
			// 		break;
					
			// 	case 11:
			// 		// IMU
			// 		if ( cntSetup1 >= 500 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(UPROW, "xa%2.3f",(double)xa / ACCELLSB);
			// 			lcdRowPrintf(LOWROW, "ya%2.3f",(double)ya / ACCELLSB);
			// 		}
			// 		break;
					
			// 	case 12:
			// 		// IMU
			// 		if ( cntSetup1 >= 500 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(UPROW, "za%2.3f",(double)za / ACCELLSB);
			// 			lcdRowPrintf(LOWROW, "xg%2.3f",(double)xg/GYROLSB);
			// 		}
			// 		break;
					
			// 	case 13:
			// 		// IMU
			// 		if ( cntSetup1 >= 500 ) {
			// 			cntSetup1 = 0;
			// 			lcdRowPrintf(UPROW, "yg%2.3f",(double)yg/GYROLSB);
			// 			lcdRowPrintf(LOWROW, "zg%2.3f",(double)zg/GYROLSB);
			// 		}
			// 		break;
			// }
			break;
		//------------------------------------------------------------------
		// 位置固定デモ
		//------------------------------------------------------------------
		case 0xa:
			
			break;
		//------------------------------------------------------------------
		// MicroSD
		//------------------------------------------------------------------
		case 0xb:
			
			break;
		//------------------------------------------------------------------
		// キャリブレーション
		//------------------------------------------------------------------
		case 0xc:
			
			break;
		//------------------------------------------------------------------
		// フラッシュ
		//------------------------------------------------------------------
		case 0xd:
			
			break;

	default:
		lcdRowPrintf(UPROW, "%#x     ", getSWrotary());
		lcdRowPrintf(LOWROW, "none    ");
		break;
	}
}
///////////////////////////////////////////////////////////////////////////////////////
// モジュール名 data_select
// 処理概要     タクトスイッチで0,1に変化させる
// 引数         data: 変化させる変数 button: どのスイッチで変化させるか
// 戻り値       なし
///////////////////////////////////////////////////////////////////////////////////////
void data_select ( uint8_t *data , uint8_t button )
{
	if ( taswGet() == button ) {
		if ( *data == 1 && push == 0) {
			push = 1;
			*data = 0;
		} else if ( *data == 0 && push == 0) {
			push = 1;
			*data = 1;
		}
	} else {
		push = 0;
	}
}
///////////////////////////////////////////////////////////////////////////////////////
// モジュール名 data_tuningUD
// 処理概要     タクトスイッチでdataを加減する
// 引数         data: 加減させる変数 add: 0: 変化量 dir: 0:上下 1:左右
// 戻り値       なし
///////////////////////////////////////////////////////////////////////////////////////
void data_tuningUD ( void *data, uint8_t add )
{
	int16_t *data2 = (int16_t*)data;	// short型ポインタにキャスト
	
	if ( cntSetup2 >= 50 ) {
		if ( taswGet() == SW_UP || taswGet() == SW_DOWN ) {
			cntSwitchUD++; // 長押し時間計測
			if ( taswGet() == SW_TOP  ) {
				// インクリメント
				if ( cntSwitchUD >= 20 ) {	// 長押し処理
					*data2 += add;
				} else if (pushUD == 0) {	// 1回押し処理
					pushUD = 1;
					*data2 += add;
				}
			} else if ( taswGet() == SW_DOWN  ) {
				// デクリメント
				if ( cntSwitchUD >= 20 ) {	// 長押し処理
					*data2 -= add;
				} else if (pushUD == 0) {	// 1回押し処理
					pushUD = 1;
					*data2 -= add;
				}
			}
		} else {
			pushUD = 0;
			cntSwitchUD = 0;
		}
		cntSetup2 = 0;
	}
}
///////////////////////////////////////////////////////////////////////////////////////
// モジュール名 data_tuningUD
// 処理概要     タクトスイッチでdataを加減する
// 引数         data: 加減させる変数 add: 0: 変化量 dir: 0:上下 1:左右
// 戻り値       なし
///////////////////////////////////////////////////////////////////////////////////////
void data_tuningLR ( void *data, uint8_t add )
{
	int16_t *data2 = (int16_t*)data;	// short型ポインタにキャスト

	if ( cntSetup3 >= 50 ) {
		if ( taswGet() == SW_LEFT || taswGet() == SW_RIGHT ) {
			cntSwitchLR++; // 長押し時間計測
			if ( taswGet() == SW_RIGHT  ) {
				// インクリメント
				if ( cntSwitchLR >= 20 ) {	// 長押し処理
					*data2 += add;
				} else if (pushLR == 0) {	// 1回押し処理
					pushLR = 1;
					*data2 += add;
				}
			} else if ( taswGet() == SW_LEFT  ) {
				// デクリメント
				if ( cntSwitchLR >= 20 ) {	// 長押し処理
					*data2 -= add;
				} else if (pushLR == 0) {	// 1回押し処理
					pushLR = 1;
					*data2 -= add;
				}
			}
		} else {
			pushLR = 0;
			cntSwitchLR = 0;
		}
		cntSetup3 = 0;
	}
}
/////////////////////////////////////////////////////////////////////////////////
// モジュール名 fixSpeedSetting
// 処理概要     速度パラメータを固定値にする
// 引数         なし
// 戻り値       0: 速度一定にしない　1: 速度一定にする
/////////////////////////////////////////////////////////////////////////////////
uint8_t fixSpeedSetting ( void )
{
	uint8_t ret = 0;
	
	// if ( setting_1meter == 1 ) {
	// 	speed_straight		= 10;
	// 	speed_curve_brake	= 10;
	// 	speed_curve_r600	= 10;
	// 	speed_curve_r450	= 10;
	// 	speed_curve_straight	= 10;
		
	// 	speed_crossline		= 10;
	// 	speed_ckank_trace	= 10;
	// 	speed_rightclank_curve	= 10;
	// 	speed_rightclank_escape	= 10;
	// 	speed_leftclank_curve	= 10;
	// 	speed_leftclank_escape	= 10;
		
	// 	speed_halfine		= 10;
	// 	speed_rightchange_trace = 10;
	// 	speed_rightchange_curve	= 10;
	// 	speed_rightchange_escape= 10;
	// 	speed_leftchange_trace 	= 10;
	// 	speed_leftchange_curve	= 10;
	// 	speed_leftchange_escape	= 10;
		
	// 	speed_slope_brake	= 10;
	// 	speed_slope_trace	= 10;
		
	// 	fixSpeed = 1;
	// 	ret = 1;
	// } else if ( setting_2meter == 1 ) {
	// 	speed_straight		= 20;
	// 	speed_curve_brake	= 20;
	// 	speed_curve_r600	= 20;
	// 	speed_curve_r450	= 20;
	// 	speed_curve_straight	= 20;
		
	// 	speed_crossline		= 20;
	// 	speed_ckank_trace	= 16;
	// 	speed_rightclank_curve	= 16;
	// 	speed_rightclank_escape	= 20;
	// 	speed_leftclank_curve	= 16;
	// 	speed_leftclank_escape	= 20;
		
	// 	speed_halfine		= 20;
	// 	speed_rightchange_trace = 20;
	// 	speed_rightchange_curve	= 20;
	// 	speed_rightchange_escape= 20;
	// 	speed_leftchange_trace 	= 20;
	// 	speed_leftchange_curve	= 20;
	// 	speed_leftchange_escape	= 20;
		
	// 	speed_slope_brake	= 20;
	// 	speed_slope_trace	= 20;
		
	// 	fixSpeed = 1;
	// 	ret = 1;
	// } else if ( setting_3meter == 1 ) {
	// 	speed_straight		= 30;
	// 	speed_curve_brake	= 30;
	// 	speed_curve_r600	= 30;
	// 	speed_curve_r450	= 30;
	// 	speed_curve_straight	= 30;
		
	// 	speed_crossline		= 25;
	// 	speed_ckank_trace	= 16;
	// 	speed_rightclank_curve	= 16;
	// 	speed_rightclank_escape	= 30;
	// 	speed_leftclank_curve	= 16;
	// 	speed_leftclank_escape	= 30;
		
	// 	speed_halfine		= 30;
	// 	speed_rightchange_trace = 30;
	// 	speed_rightchange_curve	= 30;
	// 	speed_rightchange_escape= 30;
	// 	speed_leftchange_trace 	= 30;
	// 	speed_leftchange_curve	= 30;
	// 	speed_leftchange_escape	= 30;
		
	// 	speed_slope_brake	= 20;
	// 	speed_slope_trace	= 30;
		
	// 	fixSpeed = 1;
	// 	ret = 1;
	// }
	
	return ret;
}
